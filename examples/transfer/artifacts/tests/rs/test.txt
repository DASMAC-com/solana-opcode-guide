#[test]
fn test_rs() {
    let setup = setup_test(ProgramLanguage::Rust);
    let (happy_path_instruction, happy_path_accounts) = happy_path_setup(setup.program_id);

    // Check no accounts passed.
    let mut instruction = happy_path_instruction.clone();
    instruction.accounts.clear();
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &[],
        &[Check::err(ProgramError::Custom(E_N_ACCOUNTS))],
    );

    // Check nonzero sender data length.
    let mut accounts = happy_path_accounts.clone();
    accounts[AccountIndex::Sender as usize].1.data = vec![0];
    setup.mollusk.process_and_validate_instruction(
        &happy_path_instruction,
        &accounts,
        &[Check::err(ProgramError::InvalidArgument)],
    );

    // Check duplicate recipient account: just transfers Lamports back to sender.
    instruction = happy_path_instruction.clone();
    instruction.accounts[AccountIndex::Recipient as usize] =
        happy_path_instruction.accounts[AccountIndex::Sender as usize].clone();
    accounts = happy_path_accounts.clone();
    accounts[AccountIndex::Recipient as usize] =
        happy_path_accounts[AccountIndex::Sender as usize].clone();
    setup
        .mollusk
        .process_and_validate_instruction(&instruction, &accounts, &[Check::success()]);

    // Check nonzero recipient data length: still parses and transfers Lamports.
    accounts = happy_path_accounts.clone();
    accounts[AccountIndex::Recipient as usize].1.data = vec![0];
    setup.mollusk.process_and_validate_instruction(
        &happy_path_instruction,
        &accounts,
        &happy_path_checks(&happy_path_instruction, EXPECTED_RS_COMPUTE_UNITS),
    );

    // Check duplicate system program account.
    instruction = happy_path_instruction.clone();
    instruction.accounts[AccountIndex::SystemProgram as usize] =
        happy_path_instruction.accounts[AccountIndex::Recipient as usize].clone();
    accounts = happy_path_accounts.clone();
    accounts[AccountIndex::SystemProgram as usize] =
        happy_path_accounts[AccountIndex::Recipient as usize].clone();
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &accounts,
        &[Check::err(ProgramError::NotEnoughAccountKeys)],
    );

    // Check invalid instruction data length.
    instruction = happy_path_instruction.clone();
    instruction.data.clear();
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &happy_path_accounts,
        &[Check::err(ProgramError::Custom(E_INSTRUCTION_DATA_LENGTH))],
    );

    // Check insufficient Lamports.
    accounts = happy_path_accounts.clone();
    accounts[AccountIndex::Sender as usize].1.lamports = TRANSFER_AMOUNT - 1;
    setup.mollusk.process_and_validate_instruction(
        &happy_path_instruction,
        &accounts,
        &[Check::err(ProgramError::Custom(E_INSUFFICIENT_LAMPORTS))],
    );

    // Check invalid System Program account.
    let mock_pubkey = Pubkey::new_unique();
    assert_ne!(
        mock_pubkey,
        happy_path_instruction.accounts[AccountIndex::SystemProgram as usize].pubkey
    );
    accounts = happy_path_accounts.clone();
    instruction = happy_path_instruction.clone();
    instruction.accounts[AccountIndex::SystemProgram as usize].pubkey = mock_pubkey;
    accounts[AccountIndex::SystemProgram as usize].0 = mock_pubkey;
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &accounts,
        &[Check::err(ProgramError::NotEnoughAccountKeys)],
    );

    // Check sender is not signer.
    instruction = happy_path_instruction.clone();
    instruction.accounts[AccountIndex::Sender as usize].is_signer = false;
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &happy_path_accounts,
        &[Check::instruction_err(
            InstructionError::PrivilegeEscalation,
        )],
    );

    // Check sender is not writable.
    instruction = happy_path_instruction.clone();
    instruction.accounts[AccountIndex::Sender as usize].is_writable = false;
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &happy_path_accounts,
        &[Check::instruction_err(
            InstructionError::PrivilegeEscalation,
        )],
    );

    // Check sender is executable.
    accounts = happy_path_accounts.clone();
    accounts[AccountIndex::Sender as usize].1.executable = true;
    setup.mollusk.process_and_validate_instruction(
        &happy_path_instruction,
        &accounts,
        &[Check::instruction_err(
            InstructionError::UnbalancedInstruction,
        )],
    );

    // Check recipient is signer.
    instruction = happy_path_instruction.clone();
    instruction.accounts[AccountIndex::Recipient as usize].is_signer = true;
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &happy_path_accounts,
        &[Check::success()],
    );

    // Check recipient is not writable.
    instruction = happy_path_instruction.clone();
    instruction.accounts[AccountIndex::Recipient as usize].is_writable = false;
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &happy_path_accounts,
        &[Check::instruction_err(
            InstructionError::PrivilegeEscalation,
        )],
    );

    // Check recipient is executable.
    accounts = happy_path_accounts.clone();
    accounts[AccountIndex::Recipient as usize].1.executable = true;
    setup.mollusk.process_and_validate_instruction(
        &happy_path_instruction,
        &accounts,
        &[Check::instruction_err(
            InstructionError::ExternalAccountLamportSpend,
        )],
    );

    // Check happy path.
    setup.mollusk.process_and_validate_instruction(
        &happy_path_instruction,
        &happy_path_accounts,
        &happy_path_checks(&happy_path_instruction, EXPECTED_RS_COMPUTE_UNITS),
    );
}