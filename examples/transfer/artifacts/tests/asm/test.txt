#[test]
fn test_asm() {
    let setup = setup_test(ProgramLanguage::Assembly);

    // Set up happy path accounts and instruction data.
    let (system_program, system_account) = program::keyed_account_for_system_program();
    let happy_path_instruction = Instruction::new_with_bytes(
        setup.program_id,
        &TRANSFER_AMOUNT.to_le_bytes(),
        vec![
            AccountMeta::new(Pubkey::new_unique(), true),
            AccountMeta::new(Pubkey::new_unique(), false),
            AccountMeta::new_readonly(system_program, false),
        ],
    );
    let happy_path_accounts = vec![
        (
            happy_path_instruction.accounts[AccountIndex::Sender as usize].pubkey,
            Account::new(TRANSFER_AMOUNT + COMPUTE_UNIT_OVERHEAD, 0, &system_program),
        ),
        (
            happy_path_instruction.accounts[AccountIndex::Recipient as usize].pubkey,
            Account::new(0, 0, &system_program),
        ),
        (system_program, system_account.clone()),
    ];

    // Check no accounts passed.
    let mut instruction = happy_path_instruction.clone();
    instruction.accounts.clear();
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &[],
        &[Check::err(ProgramError::Custom(E_N_ACCOUNTS))],
    );

    // Check nonzero sender data length.
    let mut accounts = happy_path_accounts.clone();
    accounts[AccountIndex::Sender as usize].1.data = vec![0];
    setup.mollusk.process_and_validate_instruction(
        &happy_path_instruction,
        &accounts,
        &[Check::err(ProgramError::Custom(
            E_DATA_LENGTH_NONZERO_SENDER,
        ))],
    );

    // Check duplicate recipient account.
    instruction = happy_path_instruction.clone();
    instruction.accounts[AccountIndex::Recipient as usize] =
        happy_path_instruction.accounts[AccountIndex::Sender as usize].clone();
    accounts = happy_path_accounts.clone();
    accounts[AccountIndex::Recipient as usize] =
        happy_path_accounts[AccountIndex::Sender as usize].clone();
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &accounts,
        &[Check::err(ProgramError::Custom(
            E_DUPLICATE_ACCOUNT_RECIPIENT,
        ))],
    );

    // Check nonzero recipient data length.
    accounts = happy_path_accounts.clone();
    accounts[AccountIndex::Recipient as usize].1.data = vec![0];
    setup.mollusk.process_and_validate_instruction(
        &happy_path_instruction,
        &accounts,
        &[Check::err(ProgramError::Custom(
            E_DATA_LENGTH_NONZERO_RECIPIENT,
        ))],
    );

    // Check duplicate system program account.
    instruction = happy_path_instruction.clone();
    instruction.accounts[AccountIndex::SystemProgram as usize] =
        happy_path_instruction.accounts[AccountIndex::Recipient as usize].clone();
    accounts = happy_path_accounts.clone();
    accounts[AccountIndex::SystemProgram as usize] =
        happy_path_accounts[AccountIndex::Recipient as usize].clone();
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &accounts,
        &[Check::err(ProgramError::Custom(
            E_DUPLICATE_ACCOUNT_SYSTEM_PROGRAM,
        ))],
    );

    // Check invalid instruction data length.
    instruction = happy_path_instruction.clone();
    instruction.data.clear();
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &happy_path_accounts,
        &[Check::err(ProgramError::Custom(E_INSTRUCTION_DATA_LENGTH))],
    );

    // Check insufficient Lamports.
    accounts = happy_path_accounts.clone();
    accounts[AccountIndex::Sender as usize].1.lamports = TRANSFER_AMOUNT - 1;
    setup.mollusk.process_and_validate_instruction(
        &happy_path_instruction,
        &accounts,
        &[Check::err(ProgramError::Custom(E_INSUFFICIENT_LAMPORTS))],
    );

    // Check invalid System Program account.
    let mock_pubkey = Pubkey::new_unique();
    assert_ne!(
        mock_pubkey,
        happy_path_instruction.accounts[AccountIndex::SystemProgram as usize].pubkey
    );
    accounts = happy_path_accounts.clone();
    instruction = happy_path_instruction.clone();
    instruction.accounts[AccountIndex::SystemProgram as usize].pubkey = mock_pubkey;
    accounts[AccountIndex::SystemProgram as usize].0 = mock_pubkey;
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &accounts,
        &[Check::err(ProgramError::NotEnoughAccountKeys)],
    );

    // Check sender is not signer.
    instruction = happy_path_instruction.clone();
    instruction.accounts[AccountIndex::Sender as usize].is_signer = false;
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &happy_path_accounts,
        &[Check::instruction_err(
            InstructionError::PrivilegeEscalation,
        )],
    );

    // Check sender is not writable.
    instruction = happy_path_instruction.clone();
    instruction.accounts[AccountIndex::Sender as usize].is_writable = false;
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &happy_path_accounts,
        &[Check::instruction_err(
            InstructionError::PrivilegeEscalation,
        )],
    );

    // Check sender is executable.
    accounts = happy_path_accounts.clone();
    accounts[AccountIndex::Sender as usize].1.executable = true;
    setup.mollusk.process_and_validate_instruction(
        &happy_path_instruction,
        &accounts,
        &[Check::instruction_err(
            InstructionError::UnbalancedInstruction,
        )],
    );

    // Check recipient is signer.
    instruction = happy_path_instruction.clone();
    instruction.accounts[AccountIndex::Recipient as usize].is_signer = true;
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &happy_path_accounts,
        &[Check::success()],
    );

    // Check recipient is not writable.
    instruction = happy_path_instruction.clone();
    instruction.accounts[AccountIndex::Recipient as usize].is_writable = false;
    setup.mollusk.process_and_validate_instruction(
        &instruction,
        &happy_path_accounts,
        &[Check::instruction_err(
            InstructionError::PrivilegeEscalation,
        )],
    );

    // Check recipient is executable.
    accounts = happy_path_accounts.clone();
    accounts[AccountIndex::Recipient as usize].1.executable = true;
    setup.mollusk.process_and_validate_instruction(
        &happy_path_instruction,
        &accounts,
        &[Check::instruction_err(
            InstructionError::ExternalAccountLamportSpend,
        )],
    );

    // Check happy path.
    setup.mollusk.process_and_validate_instruction(
        &happy_path_instruction,
        &happy_path_accounts,
        &[
            Check::success(),
            Check::account(
                &happy_path_instruction.accounts[AccountIndex::Recipient as usize].pubkey,
            )
            .lamports(TRANSFER_AMOUNT)
            .build(),
        ],
    );
}